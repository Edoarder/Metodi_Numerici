{
  
    
        "post0": {
            "title": "Title",
            "content": "&quot;Modulo 1&quot; . &quot;Analisi Monte-Carlo della termodinamica di network random&quot; . %matplotlib inline import matplotlib.pyplot as plt import numpy as np . def initialstate(L,random=True,cold=+1): if random: state = 2*np.random.randint(2, size=L)-1 elif cold==1: state = np.int_(np.ones(L)) elif cold==-1: state = -np.int_(np.ones(L)) else: return print(&quot;Put cold = +1 or -1&quot;) return state . def mcmove(config, beta,A): &#39;&#39;&#39;Monte Carlo move using Metropolis algorithm &#39;&#39;&#39; con=config.copy() N=con.size for i in range(N): a = np.random.randint(0, N) s = con[a] cost=sum(-s*A[a,:]*con)-sum(s*A[a,:]*con) if -cost &lt; 0: s = -s elif np.random.rand() &lt; np.exp(cost*beta): s = -s con[a] = s return con . def calcEnergy(config): &#39;&#39;&#39;Energy of a given configuration&#39;&#39;&#39; energy = 0 for i in range(len(config)): S = config[i] energy += sum(-S*A[i]*config) return energy/config.size/4 def calcMag(config): &#39;&#39;&#39;Magnetization of a given configuration&#39;&#39;&#39; mag = np.sum(config) return mag/N . ## Matrice di adiacenza per Ising 2D di lato L L=4 N=L**2 A=np.zeros((N,N)) for i in range(N): A[i,(i+1)%N] =-1 A[i,(i-1)%N] =-1 A[i,(i+L)%N] =-1 A[i,(i-L)%N] =-1 #A=np.int_(A) import networkx as nx #N=10 B=nx.adjacency_matrix(nx.watts_strogatz_graph(N, 2, .1)) #A=A-(np.eye(N)*B) B . &lt;16x16 sparse matrix of type &#39;&lt;class &#39;numpy.int64&#39;&gt;&#39; with 32 stored elements in Compressed Sparse Row format&gt; . A=-np.ones((N,N)) . meas=20 dec=10 tn=20 ma=np.zeros(tn) en=np.zeros(tn) xi=np.zeros(tn) cs=np.zeros(tn) ma2=np.zeros(tn) en2=np.zeros(tn) m2=np.zeros(meas) e2=np.zeros(meas) mm=0 ee=0 for t in np.arange(tn): state=np.ones((meas,N)) state[0]=initialstate(N,random=False,cold=+1) #state[0,:]=np.ones(N) e=np.zeros(meas) m=np.zeros(meas) m[0]=calcMag(state[0]) for i in range(meas-1): # misure for j in range(dec): # decorrelazione #print(str(i)+&quot;: &quot;+str(state)) state[i+1,:]=mcmove(state[i,:], t/(tn/5), B).copy() m[i+1]=calcMag(state[i+1,:]) e[i+1]=calcEnergy(state[i+1,:]) m2[i+1]=m[i+1]*m[i+1] e2[i+1]=e[i+1]*e[i+1] m=m[meas//10:] ma[t]=sum(m)/meas ma2[t]=sum(m2)/meas en[t]=sum(e)/meas en2[t]=sum(e2)/meas xi[t]=ma2[t]-ma[t-1]**2 cs[t]=en2[t]-en[t-1]**2 tempe=np.arange(tn)/(tn/5)+1 plt.figure() plt.subplot(221) plt.scatter(tempe,abs(ma)) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Magnetization&#39;) plt.subplot(222) plt.scatter(tempe,en) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Energy&#39;) plt.subplot(223) plt.scatter(tempe,(xi)) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Susceptibility&#39;) plt.subplot(224) plt.scatter(tempe,(cs)) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Specific heat capacity&#39;) plt.show() .",
            "url": "https://edoarder.github.io/Metodi_Numerici/2020/06/08/Pising.html",
            "relUrl": "/2020/06/08/Pising.html",
            "date": " • Jun 8, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Title",
            "content": "&quot;Modulo 2&quot; . &quot;Analisi della termodinamica di network random attraverso diagonalizzazione esatta dell&#39;Hamiltoniana&quot; . $$ mathit{H} = sum_{i,j}^L J_{ij} sigma_i^z sigma_{j}^z $$ . %matplotlib inline import matplotlib.pyplot as plt import numpy as np import scipy.sparse.linalg as ssl import scipy.sparse as ss import networkx as nx hh=0 volte=25 volte+=1 #lins=np.linspace(0,3,volte) fig, (ax1,ax2) = plt.subplots(2,1) volte2=30 #ell=13 gg=0.3 mmagz=np.zeros(volte) mmagz2=np.zeros(volte) xi=np.zeros(volte) magniz=np.zeros((volte,volte2)) magniz2=np.zeros((volte,volte2)) lind=np.linspace(0,1,volte) #nume=4 Psii=np.zeros(volte) #dens=0.15 jay=1 for ell in range(5,8): ggg=0 for numer in lind: NumTot=2**ell #ev=np.zeros((volte,NumTot)) Egs=np.zeros(volte) for vo in range(volte2): PBC=True graph=nx.fast_gnp_random_graph(ell,min(numer/ell,1),directed=True) graph2=nx.fast_gnp_random_graph(ell,min(numer/ell,1),directed=True) net=nx.adjacency_matrix(graph)-nx.adjacency_matrix(graph2) coll=ss.find(net) # Costruisco la base iSpin=np.zeros((NumTot,ell)) for ii in range(NumTot): itemp=ii for jj in range(ell): iSpin[ii,jj]=np.floor(itemp%2) itemp=itemp/2 # Costruisco l&#39;Hamiltoniana HamOut=(np.zeros((NumTot,NumTot))) for iHam in range(len(coll[2])): for ii in range(NumTot): if iSpin[ii,coll[0][iHam]]==iSpin[ii,coll[1][iHam]]: HamOut[ii,ii]=HamOut[ii,ii] + jay #* coll[2][iHam] # antiferromagnetico else: HamOut[ii,ii]=HamOut[ii,ii] - jay #* coll[2][iHam] # Sigma_z Sigma_z [coupling] for iHam in range(ell-1): for ii in range(NumTot): if iSpin[ii,iHam]==iSpin[ii,iHam+1]: HamOut[ii,ii]=HamOut[ii,ii]-1 else: HamOut[ii,ii]=HamOut[ii,ii]+1 # This implements periodic boundary conditions if PBC: for ii in range(NumTot): if iSpin[ii,ell-1]==iSpin[ii,0]: HamOut[ii,ii]=HamOut[ii,ii]-1 else: HamOut[ii,ii]=HamOut[ii,ii]+1 # Sigma_x [transverse field] contorta ma torna: in pratica cambia lo spin al sito j for iHam in range(ell): for ii in range(NumTot): if iSpin[ii,iHam]==1: Exc = ii - 2**(iHam) else: Exc = ii + 2**(iHam) HamOut[int(Exc),ii] = HamOut[int(Exc),ii] + gg #if ell==3 and dens==lind[0]: H1=HamOut # Trovo l&#39;autostato del GS #Egs[ggg]=ssl.eigsh(HamOut,2)[0][0] Psi=ssl.eigsh(HamOut,ell**2)[1].T[0] #Psii[ggg]=Psi.copy() # Calcolo la magnetizzazione #MagX=np.zeros(ell) #MagZ=np.zeros(ell) MagnetZ=0 # for iSite in range(ell): # Mx_sum=0 # for ii in range(NumTot): # if iSpin[ii,iSite] == 1: # MagZ[iSite] = MagZ[iSite] + abs(Psi[ii])**2 # Exc = ii -2**(iSite) # else: # MagZ[iSite] = MagZ[iSite] - abs(Psi[ii])**2 # Exc = ii +2**(iSite) # Mx_sum = Mx_sum + np.conjugate(Psi[ii]) * Psi[Exc] # if abs(np.imag(Mx_sum))&gt;10**(-10): # print(&quot;Non real magnetization&quot;) # MagX[iSite] = np.real(Mx_sum) for ii in range(NumTot): Mag_ii = 0 for iSite in range(ell): if iSpin[ii,iSite] == 1: Mag_ii = Mag_ii + 1 else: Mag_ii = Mag_ii - 1 MagnetZ = MagnetZ + abs(Mag_ii)*(abs(Psi[ii])**2) magniz[ggg,vo]= MagnetZ/ell magniz2[ggg,vo]=MagnetZ/ell*MagnetZ/ell mmagz[ggg]=sum(magniz[ggg])/volte2 mmagz2[ggg]=sum(magniz2[ggg])/volte2 xi[ggg]=mmagz2[ggg]-mmagz[ggg-1]*mmagz[ggg-1] #ax.plot(ggg*np.ones(volte2),magniz[ggg],&quot;o&quot;,label=dens) ggg+=1 #ax.set_ylim(0,1) ax1.plot(lind[1:],mmagz[1:],label=ell)#,color=&quot;black&quot;) ax2.plot(lind[1:],xi[1:],label=ell) ax1.legend() ax2.legend() plt.show() mmagz . array([0.98824752, 0.93109692, 0.88305858, 0.76745172, 0.50581421, 0.50156691, 0.43658293, 0.40100664, 0.35927499, 0.32644184, 0.26334788, 0.22373514, 0.27018878, 0.25112806, 0.27084591, 0.2351861 , 0.20149273, 0.28976678, 0.24169559, 0.20545148, 0.2345263 , 0.22549651, 0.2145379 , 0.22342765, 0.22836077, 0.18255556]) . # Sigma_z Sigma_z [coupling] for iHam in range(ell-1): for ii in range(NumTot): if iSpin[ii,iHam]==iSpin[ii,iHam+1]: HamOut[ii,ii]=HamOut[ii,ii]-1 else: HamOut[ii,ii]=HamOut[ii,ii]+1 # This implements periodic boundary conditions if PBC: for ii in range(NumTot): if iSpin[ii,ell-1]==iSpin[ii,0]: HamOut[ii,ii]=HamOut[ii,ii]-1 else: HamOut[ii,ii]=HamOut[ii,ii]+1 # Sigma_z [longitudinal field] for iHam in range(ell): for ii in range(NumTot): if iSpin[ii,iHam]==1: HamOut[ii,ii]=HamOut[ii,ii]-hh else: HamOut[ii,ii]=HamOut[ii,ii]+hh # Sigma_x [transverse field] contorta ma torna: in pratica cambia lo spin al sito j for iHam in range(ell): for ii in range(NumTot): if iSpin[ii,iHam]==1: Exc = ii - 2**(iHam) else: Exc = ii + 2**(iHam) HamOut[int(Exc),ii] = HamOut[int(Exc),ii] + gg .",
            "url": "https://edoarder.github.io/Metodi_Numerici/2020/06/07/Rossising_Network.html",
            "relUrl": "/2020/06/07/Rossising_Network.html",
            "date": " • Jun 7, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "$ H=-\sum [S_x S_x + S_y S_y +\delta S_z S_z]$",
            "content": "%matplotlib widget import matplotlib.pyplot as plt import numpy as np import scipy.sparse.linalg as ssl from numpy.linalg import multi_dot . Delta=0 m=10 NIter=10 # inizialize local ops I=np.eye(2,2) Sz=np.array([[0.5, 0],[0,-0.5]]) Sp=np.array([[0, 0],[1,0]]) Sm=np.array([[0, 1],[0,0]]) # initial blocks BlockSz = Sz BlockSp = Sp BlockSm = Sm BlockI = I BlockH = np.zeros((2,2)) Energy = 0 for l in range(NIter): SystSize = 2*l + 4 # Get the 2m-dimensional operators for the block + site BlockH = np.kron(BlockH, I) - Delta * np.kron(BlockSz, Sz) + 0.5 * ( np.kron(BlockSp, Sm) + np.kron(BlockSm, Sp) ) BlockSz = np.kron(BlockI, Sz) BlockSp = np.kron(BlockI, Sp) BlockSm = np.kron(BlockI, Sm) BlockI = np.kron(BlockI, I) # HAMILTONIAN MATRIX forsuperblock H_super = np.kron(BlockH, BlockI) + np.kron(BlockI, BlockH) - Delta * np.kron(BlockSz, BlockSz) + 0.5 * ( np.kron(BlockSp, BlockSm) + np.kron(BlockSm, BlockSp) ) H_super = 0.5 * (H_super + H_super.T); # ensure H is symmetric # Diagonalizing the Hamiltonian LastEnergy = Energy Energy= ssl.eigsh(H_super,1,which=&#39;SA&#39;)[0]#[0] Psi = ssl.eigsh(H_super,1,which=&#39;SA&#39;)[1].T#[0] EnergyPerBond = (Energy - LastEnergy) / 2 Ener2 = Energy / SystSize # Sigma = Psi&#39; *kron(BlockSz,BlockSz) * Psi; % n.n. ZZ correlation function # Form the reduced density matrix nr=Psi.size Dim = int(np.sqrt(nr)) PsiMatrix = np.reshape(Psi,(Dim,Dim)) Rho = np.dot(PsiMatrix, PsiMatrix.T) # Diagonalize the density matrix D,V = np.linalg.eigh(Rho) #V=V.T D=D[::-1] # descending Index=np.arange(Dim) Index=Index[::-1] V=V[:,Index] # Construct the truncation operator NKeep = min(D.size, m) Omatr = V[:,:NKeep] TruncationError = 1 - sum(D[:NKeep]) # Transform the block operators into the truncated basis BlockH = multi_dot([Omatr.T, BlockH, Omatr]) BlockSz = multi_dot([Omatr.T, BlockSz, Omatr]) BlockSp = multi_dot([Omatr.T, BlockSp, Omatr]) BlockSm = multi_dot([Omatr.T, BlockSm, Omatr]) BlockI = multi_dot([Omatr.T, BlockI, Omatr]) print(SystSize, Energy, EnergyPerBond, Ener2, TruncationError) #Spectrum=ssl.eigsh(H_super)[0] . 4 [-1.11803399] [-0.55901699] [-0.2795085] 0.0 6 [-1.7469796] [-0.31447281] [-0.29116327] 4.440892098500626e-16 8 [-2.37938524] [-0.31620282] [-0.29742316] 5.719729767594828e-07 10 [-3.01332844] [-0.3169716] [-0.30133284] 7.165868320946345e-07 12 [-3.64809254] [-0.31738205] [-0.30400771] 3.7881702987796473e-06 14 [-4.28332063] [-0.31761404] [-0.30595147] 4.350085748616728e-06 16 [-4.91886385] [-0.31777161] [-0.30742899] 9.750853244172575e-06 18 [-5.5545781] [-0.31785712] [-0.30858767] 1.0145299359498594e-05 20 [-6.19045287] [-0.31793739] [-0.30952264] 1.7108358645989696e-05 22 [-6.82638355] [-0.31796534] [-0.31029016] 1.6440535244632848e-05 .",
            "url": "https://edoarder.github.io/Metodi_Numerici/2020/06/06/DMRG-_1D_Heisemberg_XXZ.html",
            "relUrl": "/2020/06/06/DMRG-_1D_Heisemberg_XXZ.html",
            "date": " • Jun 6, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://edoarder.github.io/Metodi_Numerici/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://edoarder.github.io/Metodi_Numerici/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://edoarder.github.io/Metodi_Numerici/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}