{
  
    
        "post0": {
            "title": "Title",
            "content": "&quot;Modulo 1&quot; . &quot;Analisi Monte-Carlo della termodinamica di network random&quot; . %matplotlib inline import matplotlib.pyplot as plt import numpy as np . def initialstate(L,random=True,cold=+1): if random: state = 2*np.random.randint(2, size=L)-1 elif cold==1: state = np.int_(np.ones(L)) elif cold==-1: state = -np.int_(np.ones(L)) else: return print(&quot;Put cold = +1 or -1&quot;) return state . def mcmove(config, beta,A): &#39;&#39;&#39;Monte Carlo move using Metropolis algorithm &#39;&#39;&#39; con=config.copy() N=con.size for i in range(N): a = np.random.randint(0, N) s = con[a] cost=sum(-s*A[a,:]*con)-sum(s*A[a,:]*con) if -cost &lt; 0: s = -s elif np.random.rand() &lt; np.exp(cost*beta): s = -s con[a] = s return con . def calcEnergy(config): &#39;&#39;&#39;Energy of a given configuration&#39;&#39;&#39; energy = 0 for i in range(len(config)): S = config[i] energy += sum(-S*A[i]*config) return energy/config.size/4 def calcMag(config): &#39;&#39;&#39;Magnetization of a given configuration&#39;&#39;&#39; mag = np.sum(config) return mag/N . ## Matrice di adiacenza per Ising 2D di lato L L=4 N=L**2 A=np.zeros((N,N)) for i in range(N): A[i,(i+1)%N] =-1 A[i,(i-1)%N] =-1 A[i,(i+L)%N] =-1 A[i,(i-L)%N] =-1 #A=np.int_(A) import networkx as nx #N=10 B=nx.adjacency_matrix(nx.watts_strogatz_graph(N, 2, .1)) #A=A-(np.eye(N)*B) B . &lt;16x16 sparse matrix of type &#39;&lt;class &#39;numpy.int64&#39;&gt;&#39; with 32 stored elements in Compressed Sparse Row format&gt; . A=-np.ones((N,N)) . meas=20 dec=10 tn=20 ma=np.zeros(tn) en=np.zeros(tn) xi=np.zeros(tn) cs=np.zeros(tn) ma2=np.zeros(tn) en2=np.zeros(tn) m2=np.zeros(meas) e2=np.zeros(meas) mm=0 ee=0 for t in np.arange(tn): state=np.ones((meas,N)) state[0]=initialstate(N,random=False,cold=+1) #state[0,:]=np.ones(N) e=np.zeros(meas) m=np.zeros(meas) m[0]=calcMag(state[0]) for i in range(meas-1): # misure for j in range(dec): # decorrelazione #print(str(i)+&quot;: &quot;+str(state)) state[i+1,:]=mcmove(state[i,:], t/(tn/5), B).copy() m[i+1]=calcMag(state[i+1,:]) e[i+1]=calcEnergy(state[i+1,:]) m2[i+1]=m[i+1]*m[i+1] e2[i+1]=e[i+1]*e[i+1] m=m[meas//10:] ma[t]=sum(m)/meas ma2[t]=sum(m2)/meas en[t]=sum(e)/meas en2[t]=sum(e2)/meas xi[t]=ma2[t]-ma[t-1]**2 cs[t]=en2[t]-en[t-1]**2 tempe=np.arange(tn)/(tn/5)+1 plt.figure() plt.subplot(221) plt.scatter(tempe,abs(ma)) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Magnetization&#39;) plt.subplot(222) plt.scatter(tempe,en) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Energy&#39;) plt.subplot(223) plt.scatter(tempe,(xi)) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Susceptibility&#39;) plt.subplot(224) plt.scatter(tempe,(cs)) plt.xlabel(&#39;beta (1/T)&#39;) plt.ylabel(&#39;Specific heat capacity&#39;) plt.show() .",
            "url": "https://edoarder.github.io/Metodi_Numerici/2020/06/08/Pising.html",
            "relUrl": "/2020/06/08/Pising.html",
            "date": " • Jun 8, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "$ H=-\sum [S_x S_x + S_y S_y +\delta S_z S_z]$",
            "content": "%matplotlib widget import matplotlib.pyplot as plt import numpy as np import scipy.sparse.linalg as ssl from numpy.linalg import multi_dot . Delta=0 m=10 NIter=10 # inizialize local ops I=np.eye(2,2) Sz=np.array([[0.5, 0],[0,-0.5]]) Sp=np.array([[0, 0],[1,0]]) Sm=np.array([[0, 1],[0,0]]) # initial blocks BlockSz = Sz BlockSp = Sp BlockSm = Sm BlockI = I BlockH = np.zeros((2,2)) Energy = 0 for l in range(NIter): SystSize = 2*l + 4 # Get the 2m-dimensional operators for the block + site BlockH = np.kron(BlockH, I) - Delta * np.kron(BlockSz, Sz) + 0.5 * ( np.kron(BlockSp, Sm) + np.kron(BlockSm, Sp) ) BlockSz = np.kron(BlockI, Sz) BlockSp = np.kron(BlockI, Sp) BlockSm = np.kron(BlockI, Sm) BlockI = np.kron(BlockI, I) # HAMILTONIAN MATRIX forsuperblock H_super = np.kron(BlockH, BlockI) + np.kron(BlockI, BlockH) - Delta * np.kron(BlockSz, BlockSz) + 0.5 * ( np.kron(BlockSp, BlockSm) + np.kron(BlockSm, BlockSp) ) H_super = 0.5 * (H_super + H_super.T); # ensure H is symmetric # Diagonalizing the Hamiltonian LastEnergy = Energy Energy= ssl.eigsh(H_super,1,which=&#39;SA&#39;)[0]#[0] Psi = ssl.eigsh(H_super,1,which=&#39;SA&#39;)[1].T#[0] EnergyPerBond = (Energy - LastEnergy) / 2 Ener2 = Energy / SystSize # Sigma = Psi&#39; *kron(BlockSz,BlockSz) * Psi; % n.n. ZZ correlation function # Form the reduced density matrix nr=Psi.size Dim = int(np.sqrt(nr)) PsiMatrix = np.reshape(Psi,(Dim,Dim)) Rho = np.dot(PsiMatrix, PsiMatrix.T) # Diagonalize the density matrix D,V = np.linalg.eigh(Rho) #V=V.T D=D[::-1] # descending Index=np.arange(Dim) Index=Index[::-1] V=V[:,Index] # Construct the truncation operator NKeep = min(D.size, m) Omatr = V[:,:NKeep] TruncationError = 1 - sum(D[:NKeep]) # Transform the block operators into the truncated basis BlockH = multi_dot([Omatr.T, BlockH, Omatr]) BlockSz = multi_dot([Omatr.T, BlockSz, Omatr]) BlockSp = multi_dot([Omatr.T, BlockSp, Omatr]) BlockSm = multi_dot([Omatr.T, BlockSm, Omatr]) BlockI = multi_dot([Omatr.T, BlockI, Omatr]) print(SystSize, Energy, EnergyPerBond, Ener2, TruncationError) #Spectrum=ssl.eigsh(H_super)[0] . 4 [-1.11803399] [-0.55901699] [-0.2795085] 0.0 6 [-1.7469796] [-0.31447281] [-0.29116327] 4.440892098500626e-16 8 [-2.37938524] [-0.31620282] [-0.29742316] 5.719729767594828e-07 10 [-3.01332844] [-0.3169716] [-0.30133284] 7.165868320946345e-07 12 [-3.64809254] [-0.31738205] [-0.30400771] 3.7881702987796473e-06 14 [-4.28332063] [-0.31761404] [-0.30595147] 4.350085748616728e-06 16 [-4.91886385] [-0.31777161] [-0.30742899] 9.750853244172575e-06 18 [-5.5545781] [-0.31785712] [-0.30858767] 1.0145299359498594e-05 20 [-6.19045287] [-0.31793739] [-0.30952264] 1.7108358645989696e-05 22 [-6.82638355] [-0.31796534] [-0.31029016] 1.6440535244632848e-05 .",
            "url": "https://edoarder.github.io/Metodi_Numerici/2020/06/06/DMRG-_1D_Heisemberg_XXZ.html",
            "relUrl": "/2020/06/06/DMRG-_1D_Heisemberg_XXZ.html",
            "date": " • Jun 6, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://edoarder.github.io/Metodi_Numerici/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This is where you put the contents of your About page. Like all your pages, it’s in Markdown format. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://edoarder.github.io/Metodi_Numerici/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://edoarder.github.io/Metodi_Numerici/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}